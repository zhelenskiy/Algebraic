package rings

import abstractSumOf
import fields.DoubleField
import power
import structures.*

sealed interface Matrix<out T> {
    operator fun get(i: Int, j: Int): T
}

data class LimitedMatrix<T>(val rows: List<List<T>>) :
    Matrix<T> {

    constructor(vararg rows: List<T>) : this(rows.asList())

    val height: Int
        get() = rows.size
    val width: Int
        get() = rows.firstOrNull()?.size ?: 0

    constructor(height: Int, width: Int, generator: (i: Int, j: Int) -> T) :
            this(List(height) { i -> List(width) { j -> generator(i, j) } })

    init {
        require(rows.all { it.size == width }) { "Incorrect size" }
    }

    override operator fun get(i: Int, j: Int): T = rows[i][j]
    override fun toString(): String = rows.joinToString("\n") { it.joinToString(" ") }
}


fun <T> Matrix<T>.limit(height: Int, width: Int, offsetRows: Int = 0, offsetColumns: Int = 0) =
    LimitedMatrix(height, width) { i, j -> get(i + offsetRows, j + offsetColumns) }

context (SemiringWithOne<T>)
class InfiniteDiagMatrix<out T>(val diagItem: T) : Matrix<T> { // todo show kotlin bytecode fails here
    // todo if I make it data class and remove manual overrides, it fails
    override fun get(i: Int, j: Int): T = if (i == j) diagItem else zero
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        // todo this code is generated by idea and it is incorrect as it does not check context
        other as InfiniteDiagMatrix<*>

        if (diagItem != other.diagItem) return false

        return true
    }

    override fun hashCode(): Int {
        return diagItem?.hashCode() ?: 0
    }

    override fun toString(): String = when (diagItem) {
        zero -> "Z"
        one -> "E"
        else -> "diag($diagItem..$diagItem)"
    }

}

context (SemiringWithOne<T>)
fun <T> oneMatrix() = InfiniteDiagMatrix(one)

context (SemiringWithOne<T>)
fun <T> zeroMatrix() = InfiniteDiagMatrix(zero)

context (SemiringWithOne<T>)
open class MatrixSemiring<T> : SemiringWithOne<Matrix<T>> { // todo idea suggests to put open modifier before context keyword
    override val sum: CommutativeMonoid<Matrix<T>> = Sum()

    open inner class Sum : CommutativeMonoid<Matrix<T>> {
        override fun invoke(arg1: Matrix<T>, arg2: Matrix<T>): Matrix<T> = when {
            arg1 == zeroMatrix() -> arg2
            arg2 == zeroMatrix() -> arg1
            else -> when (arg1) {
                is InfiniteDiagMatrix -> when (arg2) {
                    is InfiniteDiagMatrix -> InfiniteDiagMatrix(arg1.diagItem + arg2.diagItem)
                    is LimitedMatrix -> sumImpl(arg2.height, arg2.width, arg1, arg2)
                }
                is LimitedMatrix -> when (arg2) {
                    is InfiniteDiagMatrix -> sumImpl(arg1.height, arg1.width, arg1, arg2)
                    is LimitedMatrix -> {
                        require(arg1.height == arg2.height && arg1.width == arg2.width)
                        sumImpl(arg1.height, arg1.width, arg1, arg2)
                    }
                }
            }
        }

        private fun sumImpl(height: Int, width: Int, arg1: Matrix<T>, arg2: Matrix<T>) =
            LimitedMatrix(height, width) { i, j -> arg1[i, j] + arg2[i, j] }

        override val identity: InfiniteDiagMatrix<T> = zeroMatrix<T>()
    }

    override val multi: Monoid<Matrix<T>> = object : Monoid<Matrix<T>> {
        override fun invoke(arg1: Matrix<T>, arg2: Matrix<T>): Matrix<T> = when {
            arg1 == zeroMatrix() || arg2 == oneMatrix() -> arg1
            arg2 == zeroMatrix() || arg1 == oneMatrix() -> arg2
            else -> when (arg1) {
                is LimitedMatrix -> when (arg2) {
                    is LimitedMatrix -> multiply(arg1, arg2)
                    is InfiniteDiagMatrix -> multiply(arg1, arg2)
                }
                is InfiniteDiagMatrix -> when (arg2) {
                    is LimitedMatrix -> multiply(arg1, arg2)
                    is InfiniteDiagMatrix -> multiply(arg1, arg2)
                }
            }
        }

        private fun multiply(arg1: InfiniteDiagMatrix<T>, arg2: InfiniteDiagMatrix<T>) =
            InfiniteDiagMatrix(arg1.diagItem * arg2.diagItem)

        private fun multiply(arg1: InfiniteDiagMatrix<T>, arg2: LimitedMatrix<T>) =
            LimitedMatrix(arg2.height, arg2.width) { i, j -> arg1.diagItem * arg2[i, j] }

        private fun multiply(arg1: LimitedMatrix<T>, arg2: InfiniteDiagMatrix<T>) =
            LimitedMatrix(arg1.height, arg1.width) { i, j -> arg1[i, j] * arg2.diagItem }

        private fun multiply(arg1: LimitedMatrix<T>, arg2: LimitedMatrix<T>): LimitedMatrix<T> {
            require(arg1.width == arg2.height) { "Bad dimensions for multiplication" }
            return LimitedMatrix(arg1.height, arg2.width) { i, j ->
                (0 until arg1.width).abstractSumOf<Int, T> { k -> arg1[i, k] * arg2[k, j] }
            }
        }

        override val identity: Matrix<T> = oneMatrix<T>()
    }
}

context (RingWithOne<T>)
class MatrixRing<T> : RingWithOne<Matrix<T>>, MatrixSemiring<T>() {
    override val sum: AbelGroup<Matrix<T>> = object : AbelGroup<Matrix<T>>, Sum() {
        override fun Matrix<T>.inverse(): Matrix<T> = when (this) {
            is LimitedMatrix -> LimitedMatrix(height, width) { i, j -> -this[i, j] }
            is InfiniteDiagMatrix -> InfiniteDiagMatrix(-this.diagItem)
        }
    }
}

context (SemiringWithOne<T>)
fun <T> fibonacci(index: ULong): T {
    val init = LimitedMatrix(listOf(zero, one))
    val multiplier = LimitedMatrix(
        listOf(zero, one),
        listOf(one, one)
    )
    with(MatrixSemiring()) {
        return (init * multiplier.power(index))[0, 0] // todo if I eval multiplier.power(index) in debugger, it fails
    }
}

context (SemiringWithOne<T>)
fun <T> factorial(n: T): T {
    var res = one
    var cur = zero
    while (cur != n) {
        cur += one
        res *= cur
    }
    return res
}

fun main() {
    with(Int32Ring) {
        with(MatrixSemiring()) { // todo if you replace it with MatrixRing bad code is generated
            val m1 = LimitedMatrix(listOf(2, 3), listOf(5, 7))
            val m2 = LimitedMatrix(listOf(11, 13), listOf(17, 19))
            println(m1 * m2)
        }
        println(List(10) { fibonacci(it.toULong()) })
        println(factorial(0))
        println(factorial(5))
    }
    with(DoubleField) {
        println(fibonacci(1_000UL))
    }
    with(BigIntRing) {
        println(fibonacci(1_000_000UL))
    }
}